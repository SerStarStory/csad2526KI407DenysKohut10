---------1---------
Write a simple cpp "Hello World" program.

Here's a simple C++ "Hello World" program:``` cpp
#include <iostream>

int main() {
    std::cout << "Hello World" << std::endl;
    return 0;
}
```

This program:
Includes the iostream library for input/output operations
Defines the main() function, which is the entry point of every C++ program
Uses std::cout to print "Hello World" to the console
Uses std::endl to add a newline and flush the output buffer
Returns 0 to indicate successful program execution


---------2---------
Please create CMakeLists.txt that will be able to compile that minimal program.

cmake_minimum_required(VERSION 3.10)

project(HelloWorld)

set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_executable(HelloWorld main.cpp)


---------3---------
Create file math_operations.h and math_operations.cpp that contains int add(int a, int b); function

I'll create the header and implementation files for the math operations.

#ifndef MATH_OPERATIONS_H
#define MATH_OPERATIONS_H

int add(int a, int b);

#endif // MATH_OPERATIONS_H


#include "math_operations.h"

int add(int a, int b) {
    return a + b;
}

These files provide:
math_operations.h: Header file with the function declaration and include guards to prevent multiple inclusions
math_operations.cpp: Implementation file with the actual add function that returns the sum of two integers

Don't forget to update your CMakeLists.txt to include the new source file:

cmake_minimum_required(VERSION 3.10)

project(HelloWorld)

set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_executable(HelloWorld main.cpp math_operations.cpp)


Create file unit_tests.cpp in folder tests and configure CMakeLists.txt. And create instructions to create test executable using Google Test

#include <gtest/gtest.h>
#include "../math_operations.h"

TEST(MathOperationsTest, AddPositiveNumbers) {
    EXPECT_EQ(add(2, 3), 5);
    EXPECT_EQ(add(10, 20), 30);
}

TEST(MathOperationsTest, AddNegativeNumbers) {
    EXPECT_EQ(add(-5, -3), -8);
    EXPECT_EQ(add(-10, -20), -30);
}

TEST(MathOperationsTest, AddMixedNumbers) {
    EXPECT_EQ(add(-1, 1), 0);
    EXPECT_EQ(add(5, -3), 2);
    EXPECT_EQ(add(-5, 3), -2);
}

TEST(MathOperationsTest, AddZero) {
    EXPECT_EQ(add(0, 0), 0);
    EXPECT_EQ(add(5, 0), 5);
    EXPECT_EQ(add(0, -5), -5);
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}


cmake_minimum_required(VERSION 3.14)

project(HelloWorld)

set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Main executable
add_executable(HelloWorld main.cpp math_operations.cpp)

# Google Test setup
include(FetchContent)
FetchContent_Declare(
    googletest
    GIT_REPOSITORY https://github.com/google/googletest.git
    GIT_TAG release-1.12.1
)
# For Windows: Prevent overriding the parent project's compiler/linker settings
set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
FetchContent_MakeAvailable(googletest)

# Enable testing
enable_testing()

# Test executable
add_executable(RunTests tests/unit_tests.cpp math_operations.cpp)
target_link_libraries(RunTests gtest gtest_main)

# Add test
add_test(NAME UnitTests COMMAND RunTests)

nstructions to Build and Run Tests with Google Test
Step 1: Configure and Build

# From project root directory
mkdir -p build
cd build
cmake ..
cmake --build .

Step 2: Run Tests
Run test executable directly
./RunTests

Features:
Google Test integration: Uses FetchContent to automatically download and configure Google Test
Multiple test cases: Tests cover positive, negative, mixed numbers, and zero
CTest support: Can run tests using CMake's testing framework
Cross-platform: Works on Windows, Linux, and macOS


---------4---------
Create a ci.bat file which create new build folder. Perform cmake --build . And have a step to run tests using ctest

I'll create a `ci.bat` file that creates a new build folder, runs cmake build, and executes tests using ctest.

@echo off
echo Starting CI Build Process...
echo.

REM Step 1: Remove old build folder if it exists and create a new one
echo [Step 1/4] Creating build folder...
if exist build rmdir /s /q build
mkdir build
if %errorlevel% neq 0 (
    echo ERROR: Failed to create build folder
    exit /b %errorlevel%
)
echo Build folder created successfully.
echo.

REM Step 2: Configure project with CMake
echo [Step 2/4] Configuring project with CMake...
cd build
cmake ..
if %errorlevel% neq 0 (
    echo ERROR: CMake configuration failed
    cd ..
    exit /b %errorlevel%
)
echo CMake configuration completed successfully.
echo.

REM Step 3: Build project
echo [Step 3/4] Building project...
cmake --build . --config Release
if %errorlevel% neq 0 (
    echo ERROR: Build failed
    cd ..
    exit /b %errorlevel%
)
echo Build completed successfully.
echo.

REM Step 4: Run tests with CTest
echo [Step 4/4] Running tests with CTest...
ctest -C Release --output-on-failure
if %errorlevel% neq 0 (
    echo ERROR: Tests failed
    cd ..
    exit /b %errorlevel%
)
echo.
echo Tests completed successfully.
echo.

cd ..
echo ========================================
echo CI Build Process Completed Successfully!
echo ========================================
exit /b 0

This batch file:
1. **Creates a new build folder**: Removes any existing `build` folder and creates a fresh one
2. **Configures with CMake**: Runs `cmake ..` to configure the project
3. **Builds the project**: Executes `cmake --build .` to compile everything
4. **Runs tests**: Uses `ctest --output-on-failure` to run all tests and show output only if tests fail

**Features:**
- Error checking after each step with appropriate exit codes
- Clear progress messages for each step
- Automatic cleanup of old build artifacts
- Returns to the project root directory after completion
- The `--output-on-failure` flag ensures you see test output when tests fail

**Usage:** Simply run from the project root directory:
ci.bat

okey now create another one for unix/macos

#!/bin/bash

set -e  # Exit on error

echo "Starting CI Build Process..."
echo ""

# Step 1: Remove old build folder if it exists and create a new one
echo "[Step 1/4] Creating build folder..."
if [ -d "build" ]; then
    rm -rf build
fi
mkdir build
echo "Build folder created successfully."
echo ""

# Step 2: Configure project with CMake
echo "[Step 2/4] Configuring project with CMake..."
cd build
cmake ..
echo "CMake configuration completed successfully."
echo ""

# Step 3: Build project
echo "[Step 3/4] Building project..."
cmake --build . --config Release
echo "Build completed successfully."
echo ""

# Step 4: Run tests with CTest
echo "[Step 4/4] Running tests with CTest..."
ctest -C Release --output-on-failure
echo ""
echo "Tests completed successfully."
echo ""

cd ..
echo "========================================"
echo "CI Build Process Completed Successfully!"
echo "========================================"
exit 0


Key differences from the Windows version:
Uses #!/bin/bash shebang
Uses set -e to exit on any error (instead of checking %errorlevel%)
Uses to check if directory exists
Uses rm -rf instead of rmdir /s /q
No need for -C Release flag on Unix/macOS (single-configuration generators like Makefile or Ninja are typically used)

To use the script:
Make it executable: chmod +x ci.sh
Run it: ./ci.sh

The script will automatically stop if any step fails due to the `set -e` flag.